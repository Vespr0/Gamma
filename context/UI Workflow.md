A Guide to Roblox Studio Development UI Programming: Components, UI Labs & Fusion 0.3This guide walks you through setting up and using a powerful, modern workflow for creating complex user interfaces in Roblox. We will use the UI Labs plugin to visually design our UI and convert it into code for Fusion 0.3, a declarative UI library.Part 1: Why This Stack? (The CS Concept)In traditional Roblox UI scripting (imperative programming), you manually create instances and write code to update them.Imperative (Default):-- We have to find the objects and change them
local label = script.Parent.Frame.HealthLabel
local button = script.Parent.Frame.HealButton

local health = 100

button.MouseButton1Click:Connect(function()
health = health + 10
label.Text = "HP: " .. health -- Manually update the text
end)
This gets incredibly complex to manage. You have to track all your connections and manually keep the UI "in sync" with your game's state.Declarative (Fusion):With Fusion, you describe what the UI should look like as a component, which is just a function. You pass it a scope (for memory management) and props (for data).-- We define a component that manages its own state
local function HealthCounter(scope, props)
-- We define the state
local health = scope:Value(100)
local healthText = scope:Computed(function(use)
return "HP: " .. use(health)
end)

    -- We return the UI description
    return scope:New("Frame")({
        Parent = props.Parent,
        [Children] = {
            scope:New("TextLabel")({
                Text = healthText -- Bind the text to our computed state
            }),
            scope:New("TextButton")({
                Text = "Heal",
                [OnEvent "MouseButton1Click"] = function()
                    health:set(health:peek() + 10) -- We just change the state
                end
            })
        }
    })

end

-- Later, in your main script:
-- local rootScope = Fusion.scoped(Fusion)
-- HealthCounter(rootScope, { Parent = someScreenGui })
Now, the component manages its own state. You just tell it where to exist. This is the "single source of truth" principle and is far more scalable.Part 2: Setup & InstallationGet Fusion 0.3: The component-based API is the modern, recommended pattern for Fusion 0.3. The best way to get it is with a package manager.Recommended: Wally: If you're not using Wally, this is the best time to start. It's the standard for managing Roblox packages.Add Fusion = "dphfox/fusion@0.3.0-beta.1" (or the latest 0.3.x tag) to your wally.toml and run wally install.Your code will then be ableto access it like your example: local Fusion = require(ReplicatedStorage.Packages.fusion).Manual: You can still find the .rbxm file on the Fusion GitHub Releases page. Look for the latest v0.3.x release.Get UI Labs Plugin:Install the plugin.Part 3: The Core Workflow (From Visual to Code)This is the main loop you'll follow.Step 1: Design Your UI Visually(This is the same as before.)Add a ScreenGui to StarterGui.Inside it, create a Frame named "CounterFrame" with a "CountLabel" and "IncrementButton".Add UICorners and style it how you like.Step 2: Convert with UI Labs(This is also the same.)Open the UI Labs plugin.Select "CounterFrame" in the Explorer.Go to the "Converter" section, select "Fusion", and click "Convert".Step 3: Refactor the Code into a ComponentUI Labs will generate static code. We need to wrap it in a function to make it a reusable component, just like your Timer example.Create a ModuleScript (e.g., in ReplicatedStorage.UI.Components) named Counter.Paste and adapt the code from UI Labs.<!-- end list -->-- This code is GENERATED by UI Labs, then REFACTORED into a component
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Fusion = require(ReplicatedStorage.Packages.fusion) -- Assuming Wally

local Children = Fusion.Children
local OnEvent = Fusion.OnEvent
local peek = Fusion.peek

-- 1. We wrap the UI Labs code in a function
local function Counter(scope, props)
-- props = props or {} -- Not needed with Luau type checking

    -- 2. We use scope:New() and parenthesis-style
    return scope:New("Frame")({
        Name = "CounterFrame",
        AnchorPoint = Vector2.new(0.5, 0.5),
        Position = UDim2.new(0.5, 0, 0.5, 0),
        Size = UDim2.new(0, 200, 0, 100),
        BackgroundColor3 = Color3.fromRGB(45, 45, 45),
        Parent = props.Parent, -- Get Parent from props

        [Children] = {
            scope:New("UICorner")({
                CornerRadius = UDim.new(0, 8)
            }),
            scope:New("TextLabel")({
                Name = "CountLabel",
                Size = UDim2.new(1, 0, 0.5, 0),
                BackgroundTransparency = 1,
                Font = Enum.Font.GothamBold,
                Text = "0", -- This is static! We'll change this.
                TextColor3 = Color3.fromRGB(255, 255, 255),
                TextSize = 24
            }),
            scope:New("TextButton")({
                Name = "IncrementButton",
                Position = UDim2.new(0, 0, 0.5, 0),
                Size = UDim2.new(1, 0, 0.5, 0),
                BackgroundColor3 = Color3.fromRGB(0, 122, 255),
                Font = Enum.Font.GothamBold,
                Text = "Increment",
                TextColor3 = Color3.fromRGB(255, 255, 255),
                TextSize = 20,

                [Children] = {
                    scope:New("UICorner")({
                        CornerRadius = UDim.new(0, 8)
                    })
                }
            })
        }
    })

end

return Counter
Part 4: From Static to Dynamic (Making it Work)Now we edit our Counter component ModuleScript to add state.-- In your Counter.lua ModuleScript
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Fusion = require(ReplicatedStorage.Packages.fusion)

local Children = Fusion.Children
local OnEvent = Fusion.OnEvent
local peek = Fusion.peek

local function Counter(scope, props)
-- 1. Define Your State (inside the component)
local countState = scope:Value(0)

    -- 2. Create Derived State
    local countText = scope:Computed(function(use)
        return "Count: " .. use(countState)
    end)

    return scope:New("Frame")({
        Name = "CounterFrame",
        Position = props.Position, -- Get dynamic props
        Size = props.Size,
        Parent = props.Parent,
        -- ... other styling ...
        BackgroundColor3 = Color3.fromRGB(45, 45, 45),

        [Children] = {
            scope:New("UICorner")({
                CornerRadius = UDim.new(0, 8)
            }),
            scope:New("TextLabel")({
                Name = "CountLabel",
                Size = UDim2.new(1, 0, 0.5, 0),
                BackgroundTransparency = 1,
                Font = Enum.Font.GothamBold,
                -- 3. BIND the Text property
                Text = countText,
                TextColor3 = Color3.fromRGB(255, 255, 255),
                TextSize = 24
            }),
            scope:New("TextButton")({
                Name = "IncrementButton",
                Position = UDim2.new(0, 0, 0.5, 0),
                Size = UDim2.new(1, 0, 0.5, 0),
                BackgroundColor3 = Color3.fromRGB(0, 122, 255),
                Font = Enum.Font.GothamBold,
                Text = "Increment",
                TextColor3 = Color3.fromRGB(255, 255, 255),
                TextSize = 20,

                -- 4. BIND the click event
                [OnEvent "MouseButton1Click"] = function()
                    local currentCount = peek(countState)
                    countState:set(currentCount + 1)
                end,

                [Children] = {
                    scope:New("UICorner")({
                        CornerRadius = UDim.new(0, 8)
                    })
                }
            })
        }
    })

end

return Counter
Part 5: Nesting Components (Your Example)This is the key. To nest a component, you just call its function inside the [Children] table of another component.Let's create a TopBar that holds your Timer component.1. The Timer Component (Based on your example)First, let's assume your Timer component is in ReplicatedStorage.UI.Components.Timer. We'll simplify it slightly for this example.-- In Timer.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Packages = ReplicatedStorage.Packages

local Fusion = require(Packages.fusion)

local Children = Fusion.Children

type UsedAs<T> = Fusion.UsedAs<T>

local function Timer(
scope: Fusion.Scope<typeof(Fusion)>,
props: {
Parent: GuiObject?,
Size: UsedAs<UDim2>,
Title: UsedAs<string>,
Start: UsedAs<number>,
LayoutOrder: UsedAs<number>,
}
)
local now = scope:Value(os.clock())

    table.insert(
    	scope,
    	RunService.RenderStepped:Connect(function()
    		now:set(os.clock())
    	end)
    )

    return scope:New("Frame")({
    	BackgroundTransparency = 1,
    	Parent = props.Parent,
    	Size = props.Size,
    	LayoutOrder = props.LayoutOrder,

    	[Children] = {
    		scope:New("UIListLayout")({
    			FillDirection = Enum.FillDirection.Vertical,
    			HorizontalAlignment = Enum.HorizontalAlignment.Center,
    			SortOrder = Enum.SortOrder.LayoutOrder,
    		}),
    		scope:New("TextLabel")({
    			Text = props.Title,
    			TextColor3 = Color3.fromRGB(200, 200, 200),
    			TextXAlignment = Enum.TextXAlignment.Center,
    			BackgroundTransparency = 1,
    			Size = UDim2.fromScale(1, 0.4),
    			Font = Enum.Font.Roboto,
    			TextScaled = true,
    		}),
    		scope:New("TextLabel")({
    			TextColor3 = Color3.fromRGB(255, 255, 255),
    			TextXAlignment = Enum.TextXAlignment.Center,
    			BackgroundTransparency = 1,
    			Size = UDim2.fromScale(1, 0.6),
    			Font = Enum.Font.RobotoMono,
    			TextScaled = true,

    			Text = scope:Computed(function(use)
    				local time = use(props.Start) - use(now)
    				local remainingTime = math.max(0, time)

    				local minutes = math.floor(remainingTime / 60)
    				local seconds = math.floor(remainingTime % 60)
    				return string.format("%02d:%02d", minutes, seconds)
    			end),
    		}),
    	},
    })

end

return Timer 2. The TopBar Component (The Parent)Now, let's create a TopBar component that uses the Timer and a PlayerList.-- In TopBar.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Fusion = require(ReplicatedStorage.Packages.fusion)
-- Import the child components
local PlayerList = require(ReplicatedStorage.UI.Components.PlayerList)
local Timer = require(ReplicatedStorage.UI.Components.Timer)

local Children = Fusion.Children

-- Define the data types for props for clarity
type PlayerData = {
Image: string,
OverlayText: string?,
OverlayColor: Color3?,
}

type EventData = {
Title: string,
Start: number,
}

local function TopBar(scope, props: {
Parent: GuiObject?,
Players: { PlayerData },
Event: Fusion.UsedAs<EventData>,
})
-- Create computed states to pass down to the Timer
local titleState = scope:Computed(function(use)
local event = use(props.Event)
return event and event.Title
end)
local startState = scope:Computed(function(use)
local event = use(props.Event)
return event and event.Start
end)

    return scope:New("Frame")({
    	Name = "TopBar",
    	Parent = props.Parent,
    	Position = UDim2.fromScale(0.5, 0),
    	AnchorPoint = Vector2.new(0.5, 0),
    	BackgroundColor3 = Color3.fromRGB(0, 0, 0),
    	BackgroundTransparency = 0.5,
    	Size = UDim2.new(0.8, 20, 0, 60),

    	[Children] = {
    		scope:New("UIListLayout")({
    			FillDirection = Enum.FillDirection.Horizontal,
    			HorizontalAlignment = Enum.HorizontalAlignment.Center,
    			VerticalAlignment = Enum.VerticalAlignment.Center,
    			SortOrder = Enum.SortOrder.LayoutOrder,
    			Padding = UDim.new(0, 10),
    		}),

    		-- *** THIS IS THE ANSWER ***
    		-- To nest components, just call them like functions
    		-- and pass the scope and props.
    		Timer(scope, {
    			Size = UDim2.new(0.2, 0, 0.8, 0),
    			Title = titleState, -- Pass derived state
    			Start = startState, -- Pass derived state
    			LayoutOrder = 0,
    		}),
    		PlayerList(scope, {
    			Size = UDim2.new(0.4, 0, 1, 0),
    			Players = props.Players, -- Pass player data down
    			LayoutOrder = 1,
    		}),
    	},
    })

end

return TopBar 3. The Main Script (To run it all)Finally, a LocalScript in StarterPlayerScripts will create the root scope and mount your TopBar.-- In StarterPlayer.StarterPlayerScripts.MainUI
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local PlayerGui = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")

local Fusion = require(ReplicatedStorage.Packages.fusion)
local TopBar = require(ReplicatedStorage.UI.Components.TopBar) -- Import TopBar

-- 1. Create a root scope for our UI
local rootScope = Fusion.scoped(Fusion)

-- 2. Create the main ScreenGui
local mainGui = rootScope:New("ScreenGui")({
Parent = PlayerGui,
ResetOnSpawn = true,
})

-- 3. Define the data for the child components
-- This would typically come from a central state store
local PLAYERS = {
{ Image = "rbxassetid://0" },
{ Image = "rbxassetid://0", OverlayText = "RIP", OverlayColor = Color3.fromRGB(255, 0, 0) },
{ Image = "rbxassetid://0" },
{ Image = "rbxassetid://0" },
}

-- We make this a state object so we can change the event later!
local eventState = rootScope:Value({
Title = "INTERMISSION",
Start = os.clock() + 300, -- Set timer for 5 minutes (300s)
})

-- 4. Mount the TopBar component
TopBar(rootScope, {
Parent = mainGui,
Players = PLAYERS,
Event = eventState, -- Pass the event state in as a prop
})

-- 5. Cleanup
script.Destroying:Connect(function()
rootScope:doCleanup()
end)
Part 6: Key Modern Fusion ConceptsPart 6: Key Fusion 0.3 Component ConceptsComponent: A function that takes scope and props and returns a UI description.scope: An object passed into your component that manages memory. You use it to create state and new instances (scope:Value, scope:New).props: A table of data passed into a component from its parent (e.g., Parent, Size, Event).scope:Value(initial): Creates a state object.scope:Computed(function(use)): Creates a derived state object.scope:ForValues(table, function): Creates instances from a table of data, and dynamically updates them when the table changes.scope:New("InstanceName")({ ... }): The recommended component-based syntax for creating an instance. You may also see the older New "Frame" { ... } (v0.2) syntax, but scope:New is preferred for components.table.insert(scope, cleanupTask): The modern way to add a cleanup task (like disconnecting an event) to the scope.Nesting: You nest components by calling them inside the [Children] table of a parent component.
